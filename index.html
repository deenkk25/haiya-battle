<!-- commit test -->

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒã‚¤ãƒ¤ãƒ¼ãƒãƒˆãƒ«ï¼ˆæœ€æ–°ç‰ˆãƒ»3ã‚«ãƒ©ãƒ çµ±åˆç‰ˆï¼‰</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100vh; overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #222 0%, #050505 60%, #000 100%);
      color: #eee;
    }

    #mainLayout{
      display:grid;
      grid-template-columns:540px 420px 420px;
      gap:12px;
      padding:12px;
      height:100%;
      align-items:flex-start;
    }

    /* ===== å·¦ï¼šç›¤é¢ï¼‹çŠ¶æ…‹ ===== */
    #leftColumn{
      display:flex;
      flex-direction:column;
      gap:8px;
      width:540px;
    }

    #boardWrapper{
      position: relative; /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºã®ãŸã‚ */
      padding:6px;
      background: radial-gradient(circle at top, #1e1e1e 0%, #090909 70%);
      border-radius:10px;
      box-shadow:0 18px 30px rgba(0,0,0,0.85);
      width: fit-content;
    }

    /* ç›¤é¢ä¸Šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼šã“ã®ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ */
    #boardUsedOverlay{
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      z-index:5;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 10px 24px rgba(0,0,0,0.55);
      font-size: 12px;
      min-height: 30px;
      max-width: 520px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .overlay-empty{ opacity:0.55; }
    .overlay-white{ border-color: rgba(245,231,197,0.55); }
    .overlay-black{ border-color: rgba(159,195,255,0.55); }

    #board{
      display:grid;
      grid-template-columns:repeat(8,64px);
      grid-template-rows:repeat(8,64px);
      border:4px solid #bca57c;
      border-radius:8px;
      background:#1b1b1b;
      transition:border-color 0.2s, box-shadow 0.2s;
    }
    #board.white-turn{ border-color:#f5e7c5; box-shadow:0 0 18px rgba(255,240,200,0.35); }
    #board.black-turn{ border-color:#7aa0ff; box-shadow:0 0 18px rgba(160,190,255,0.4); }

    .cell{
      width:64px;height:64px;position:relative;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;font-size:28px;
      transition:transform 0.08s ease-out, box-shadow 0.08s ease-out;
    }
    .dark{ background:linear-gradient(135deg,#303030,#1f1f1f); }
    .light{ background:linear-gradient(135deg,#555,#3f3f3f); }
    .cell::before{ content:""; position:absolute; inset:0; border:1px solid rgba(0,0,0,0.35); pointer-events:none; }
    .cell:hover{ transform:translateY(1px); box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08); }

    .white-piece,.black-piece{ text-shadow:0 0 6px rgba(0,0,0,0.9); }
    .white-piece{ color:#f5e7c5; }
    .black-piece{ color:#9fc3ff; transform:rotate(180deg); }

    /* âœ… é­”å°å£«â‚ï¼šãã‚Œãã‚Œã®é™£å–¶è‰²ã«å¯„ã›ã‚‹ï¼ˆç™½=æš–è‰²å¯„ã‚Š/é»’=é’å¯„ã‚Šï¼‰ */
    .white-piece.mage{ color:#f3d9c9; }  /* ç™½é§’ã®è‰²å‘³ã«å¯„ã›ãŸæ·¡ã„æš–è‰² */
    .black-piece.mage{ color:#b7ccff; }  /* é»’é§’ã®é’å‘³ã«å¯„ã›ãŸæ˜ã‚‹ã„é’ */

    .cell .white-piece.king, .cell .black-piece.king,
    .cell .white-piece.castle, .cell .black-piece.castle { font-size:32px; }

    .selected{ box-shadow:inset 0 0 0 2px rgba(255,255,180,0.7); }
    .highlight{ box-shadow:inset 0 0 0 2px rgba(120,220,160,0.8); }

    .terrain-block-white{ box-shadow:inset 0 0 0 2px rgba(120,190,255,0.7); }
    .terrain-block-black{ box-shadow:inset 0 0 0 2px rgba(255,170,90,0.7); }
    .stone-block{
      box-shadow:inset 0 0 0 2px rgba(200,200,200,0.7);
      background:linear-gradient(135deg,#777,#444);
    }
    .trap-revealed{ box-shadow:inset 0 0 0 2px rgba(185,140,255,0.85); }

    .aoe-preview-white{ box-shadow:inset 0 0 0 2px rgba(250,230,150,0.8); }
    .aoe-preview-black{ box-shadow:inset 0 0 0 2px rgba(150,190,250,0.8); }

    .last-turn-white::after,.last-turn-black::after{
      content:"";position:absolute;inset:4px;border-radius:6px;pointer-events:none;
    }
    .last-turn-white::after{ border:2px solid rgba(255,235,150,0.85); }
    .last-turn-black::after{ border:2px solid rgba(150,195,255,0.9); }

    .hp-label{
      position:absolute;bottom:4px;right:4px;
      font-size:13px;font-weight:bold;opacity:0.98;text-shadow:0 0 3px #000;
    }
    .hp-high{ color:#7CFC00; }
    .hp-mid{ color:#FFD700; }
    .hp-low{ color:#FF4500; }

    .cell-symbol{
      position:absolute;top:4px;left:4px;font-size:18px;opacity:0.9;pointer-events:none;
    }

    .buff-symbol{
      position:absolute;top:4px;right:4px;font-size:16px;
      pointer-events:none;text-shadow:0 0 4px #000;
    }
    .buff-symbol-left{ left:4px; right:auto; }
    .buff-symbol-shield{ color:#ffd700; }
    .buff-symbol-prayer{ color:#a0e0ff; }

    #bottomStatus{
      padding:8px;background:rgba(12,12,12,0.9);
      border-radius:8px;border:1px solid #333;
      box-shadow:0 8px 18px rgba(0,0,0,0.8);
      display:flex;flex-direction:column;gap:6px;
    }

    #effectsBar{ display:flex; gap:8px; font-size:12px; color:#ddd; }
    .effects-side{ flex:1; }
    .effects-label{ font-weight:bold;margin-bottom:2px;font-size:11px; }
    .effects-icons span{
      margin-right:4px;padding:2px 5px;border-radius:5px;
      background:#222;border:1px solid #444;
      box-shadow:0 0 4px rgba(0,0,0,0.7);
      font-size:11px;white-space:nowrap;display:inline-flex;align-items:center;gap:3px;
    }

    #hayerStatus{ display:flex; gap:8px; font-size:12px; }
    .hayer-side{ flex:1; }
    .hayer-title{ font-size:11px; margin-bottom:2px; }
    .hayer-pills{ display:flex; flex-wrap:wrap; gap:4px; }
    .hayer-pill{
      padding:2px 6px;border-radius:999px;background:#222;border:1px solid #444;
      font-size:11px;opacity:0.65;
    }
    .hayer-pill.used{ opacity:0.25; text-decoration:line-through; }

    /* ===== ä¸­å¤®ï¼šæ“ä½œUI ===== */
    #centerColumn{ display:flex; flex-direction:column; gap:8px; height:100%; }
    h1{ margin:0 0 4px; font-size:24px; letter-spacing:0.06em; }

    #modeButtons{ display:flex; gap:8px; margin-bottom:2px; }
    #modeButtons button{
      padding:4px 10px;border-radius:6px;border:1px solid #777;
      background:linear-gradient(to bottom,#444,#151515);color:#eee;
      cursor:pointer;font-size:12px; box-shadow:0 2px 4px rgba(0,0,0,0.7);
    }
    #modeButtons button.active{ background:linear-gradient(to bottom,#777,#333); border-color:#fff; }

    #bgmBtn{
      align-self:flex-start;
      padding:4px 10px;border-radius:6px;border:1px solid #777;
      background:linear-gradient(to bottom,#444,#151515);color:#eee;
      cursor:pointer;font-size:12px;box-shadow:0 2px 4px rgba(0,0,0,0.7);
    }

    .panel{
      background:rgba(12,12,12,0.95);border-radius:8px;border:1px solid #333;
      padding:8px 10px;font-size:13px;box-shadow:0 8px 18px rgba(0,0,0,0.7);
    }

    #phasePanel{ min-height:70px; }
    .phase-card{
      padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);
      background:radial-gradient(circle at top,#2a2520 0%,#14110f 60%,#080707 100%);
      font-size:13px;
    }
    .phase-white{
      background:radial-gradient(circle at top,#3d3422 0%,#15120b 60%,#050403 100%);
      border-color:rgba(255,240,180,0.4);
    }
    .phase-black{
      background:radial-gradient(circle at top,#1f2738 0%,#0a0c12 60%,#040509 100%);
      border-color:rgba(160,190,255,0.45);
    }
    .phase-result .phase-main{ font-size:16px; }
    .phase-main{ font-weight:bold; margin-bottom:2px; }
    .phase-sub{ font-size:12px; color:#ddd; }

    #handsWrapper{ display:flex; gap:8px; }
    .handCol{ flex:1; }
    .handCol-title{ font-size:11px; margin-bottom:2px; color:#ccc; }

    .card{
      border:1px solid #555;padding:6px;margin-bottom:4px;cursor:pointer;
      background:#1f1f1f;border-radius:6px;font-size:12px;
      box-shadow:0 4px 8px rgba(0,0,0,0.8);
    }
    .card:hover{ background:#2a2a2a; }
    .card.disabled{ opacity:0.4; cursor:default; box-shadow:none; }

    #endTurnBtn{
      margin-top:4px;
      padding:6px 10px;border-radius:8px;border:1px solid #888;
      background:linear-gradient(to bottom,#444,#181818);
      color:#eee;cursor:pointer;font-size:13px;
      box-shadow:0 3px 6px rgba(0,0,0,0.8);
    }
    #endTurnBtn:disabled{ opacity:0.45; cursor:default; }

    /* âœ… ã‚¿ãƒ¼ãƒ³çµ‚äº†ãƒœã‚¿ãƒ³ä¸‹ï¼šã‚·ãƒ¼ãƒ³ã‚¤ãƒ©ã‚¹ãƒˆ */
    #sceneBox{
      border-radius:10px;
      border:1px solid #333;
      background: rgba(12,12,12,0.95);
      box-shadow:0 8px 18px rgba(0,0,0,0.7);
      overflow:hidden;
      height: 170px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #sceneImage{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      filter: saturate(1.05) contrast(1.05);
    }

    /* ===== å³ï¼šæˆ¦æ³ï¼‹ãƒªãƒ—ãƒ¬ã‚¤ï¼‹ãƒ­ã‚°ï¼‹èª¬æ˜ ===== */
    #rightColumn{ display:flex; flex-direction:column; gap:8px; height:100%; }

    #battlePanel,#replayPanel,#logPanel{
      background:rgba(12,12,12,0.95);
      border-radius:8px;border:1px solid #333;
      padding:8px 10px;font-size:13px;
      box-shadow:0 8px 18px rgba(0,0,0,0.7);
    }

    #battleContent{ display:flex; gap:8px; font-size:12px; }
    .battle-side{ flex:1; }
    .battle-side-title{ font-weight:bold; margin-bottom:2px; font-size:12px; }

    #replayBody{ font-size:12px;color:#ddd;min-height:36px;white-space:normal; }

    #logPanelTitle{ font-size:13px;font-weight:bold;margin-bottom:4px; }

    #log{
      font-size:11px;background:#111;border-radius:6px;padding:6px;
      max-height:270px;overflow-y:auto;
    }

    /* âœ… ã‚²ãƒ¼ãƒ èª¬æ˜ï¼šãƒ­ã‚°ã®ä¸‹ã«ç§»å‹• */
    #notesUnderLog{
      margin-top:8px;
      padding:8px;
      border-radius:8px;
      border:1px solid #333;
      background: rgba(12,12,12,0.65);
      font-size:11px;
      color:#aaa;
      line-height:1.5;
    }
  </style>
</head>

<body>
  <div id="mainLayout">
    <!-- å·¦ï¼šç›¤é¢ï¼‹çŠ¶æ…‹ -->
    <div id="leftColumn">
      <div id="boardWrapper">
        <div id="boardUsedOverlay" class="overlay-empty">ä½¿ç”¨ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ï¼šãªã—</div>
        <div id="board"></div>
      </div>

      <div id="bottomStatus">
        <div id="effectsBar"></div>
        <div id="hayerStatus">
          <div class="hayer-side">
            <div class="hayer-title">ç™½ã®ãƒã‚¤ãƒ¤ãƒ¼ï¼ˆä½¿ç”¨çŠ¶æ³ï¼‰</div>
            <div id="hayerWhiteStatus" class="hayer-pills"></div>
          </div>
          <div class="hayer-side">
            <div class="hayer-title">é»’ã®ãƒã‚¤ãƒ¤ãƒ¼ï¼ˆä½¿ç”¨çŠ¶æ³ï¼‰</div>
            <div id="hayerBlackStatus" class="hayer-pills"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ä¸­å¤®ï¼šæ“ä½œUI -->
    <div id="centerColumn">
      <h1>ãƒã‚¤ãƒ¤ãƒ¼ãƒãƒˆãƒ«</h1>

      <div id="modeButtons">
        <button id="modeCpuBtn" class="active">CPUæˆ¦ï¼ˆç™½vsCPUé»’ï¼‰</button>
        <button id="modePvpBtn">å¯¾äººæˆ¦ï¼ˆç™½vsé»’ï¼‰</button>
      </div>
      <button id="bgmBtn">BGM å†ç”Ÿ</button>

      <div id="phasePanel" class="panel"></div>

      <div id="handsWrapper">
        <div class="handCol">
          <div class="handCol-title">ç™½ã®æ‰‹æœ­ï¼ˆæœ€å¤§3æšï¼‰</div>
          <div id="handWhite"></div>
        </div>
        <div class="handCol">
          <div class="handCol-title">é»’ã®æ‰‹æœ­ï¼ˆæœ€å¤§3æšï¼‰</div>
          <div id="handBlack"></div>
        </div>
      </div>

      <button id="endTurnBtn">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>

      <!-- âœ… ã‚¿ãƒ¼ãƒ³çµ‚äº†ãƒœã‚¿ãƒ³ã®ä¸‹ã«ã‚¤ãƒ©ã‚¹ãƒˆ -->
      <div id="sceneBox" aria-label="scene">
        <img id="sceneImage" src="battle.png" alt="scene" />
      </div>
    </div>

    <!-- å³ï¼šæˆ¦æ³ï¼‹ãƒªãƒ—ãƒ¬ã‚¤ï¼‹ãƒ­ã‚°ï¼‹èª¬æ˜ -->
    <div id="rightColumn">
      <div id="battlePanel">
        <div class="panel-title">æˆ¦æ³</div>
        <div id="battleContent">
          <div class="battle-side" id="battleWhite"></div>
          <div class="battle-side" id="battleBlack"></div>
        </div>
      </div>

      <div id="replayPanel">
        <div class="panel-title">å‰ã‚¿ãƒ¼ãƒ³ã®ãƒªãƒ—ãƒ¬ã‚¤</div>
        <div id="replayBody">ã¾ã å‰ã‚¿ãƒ¼ãƒ³ã®æƒ…å ±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>
      </div>

      <div id="logPanel">
        <div id="logPanelTitle">ãƒ­ã‚°</div>
        <div id="log"></div>

        <!-- âœ… èª¬æ˜ã‚’ãƒ­ã‚°ã®ä¸‹ã¸ -->
        <div id="notesUnderLog">
          ãƒ»æ‰‹æœ­ãŒã‚ã‚‹ã‚¿ãƒ¼ãƒ³ã¯å¿…ãšãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’1æšä½¿ç”¨ï¼ˆå…ˆè¡Œ1ã‚¿ãƒ¼ãƒ³ç›®ã‚’é™¤ãï¼‰<br>
          ãƒ»ãƒã‚¤ãƒ¤ãƒ¼ä½¿ç”¨ï¼‹é§’ã®ç§»å‹• ã¾ãŸã¯ ã‚¿ãƒ¼ãƒ³çµ‚äº†ãƒœã‚¿ãƒ³ã§ã‚¿ãƒ¼ãƒ³çµ‚äº†<br>
          ãƒ»ã‚¿ãƒ¼ãƒ³åˆ¶é™ï¼ˆ60ã‚¿ãƒ¼ãƒ³ï¼‰ã¾ãŸã¯ãƒã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Œãƒ»å…¨æ»…ã§å‹æ•—åˆ¤å®š
        </div>
      </div>
    </div>
  </div>

  <script>
    const BOARD_SIZE = 8;
    const MAX_TURNS = 60;
    const MAX_HAND = 3;

    const PieceType = {
      KING:'king', KNIGHT:'knight', FOOTMAN:'footman', ARCHER:'archer',
      CASTLE:'castle', MONK:'monk', SHIELD:'shield', MAGE:'mage', ASSASSIN:'assassin',
    };

    const HP_KING=5, HP_FOOTMAN=2, HP_KNIGHT=2, HP_ARCHER=2, HP_MONK=1, HP_MAGE=1, HP_ASSASSIN=1, HP_SHIELD=3, HP_CASTLE=4;

    let gameMode='cpu';
    let cpuPlayer='black';

    let bgmEnabled=false;
    const bgmAudio=new Audio('bgm.mp3');
    bgmAudio.loop=true; bgmAudio.volume=0.4;

    const sfx = {
      move:new Audio('move.mp3'),
      attack:new Audio('attack.mp3'),
      card:new Audio('card.mp3'),
      win:new Audio('win.mp3'),
    };
    function playSfx(name){
      const a=sfx[name]; if(!a) return;
      try{ a.currentTime=0; a.play(); }catch(e){}
    }
    function toggleBgm(){
      bgmEnabled=!bgmEnabled;
      if(bgmEnabled) bgmAudio.play().catch(()=>{});
      else bgmAudio.pause();
      document.getElementById('bgmBtn').textContent = bgmEnabled ? 'BGM åœæ­¢' : 'BGM å†ç”Ÿ';
    }

    let state = {
      board:[],
      currentPlayer:'white',
      selectedCell:null,
      validMoves:[],
      decks:{white:[],black:[]},
      hands:{white:[],black:[]},
      discard:[],
      activeEffect:null,
      targeting:null,
      prayerShield:{white:false, black:false},
      terrainBlocks:[],
      traps:[],
      aoePreview:[],
      winner:null,
      log:[],
      turnCount:1,
      cardPlayedThisTurn:false,
      guardBarrier:{white:null, black:null},
      timeStop:{white:null, black:null},
      cardLock:{white:false, black:false},
      turnActionCells:[],
      lastTurnHighlight:null,
      lastReplayText:'',
      turnStartLogIndex:0,
      usedCardThisTurn:null
    };

    const CARD_TEMPLATES = [
      { id:'speed', name:'è¿½ã„é¢¨', icon:'ğŸ’¨', description:'ã“ã®ã‚¿ãƒ¼ãƒ³ã ã‘ã€æ­©å…µãƒ»åƒ§ä¾¶ãƒ»å¼“å…µãƒ»é¨é¦¬ãƒ»ç›¾å…µãƒ»æš—æ®ºè€…ãƒ»é­”å°å£«ã®ç§»å‹•æ€§èƒ½ãŒå¤§å¹…ã‚¢ãƒƒãƒ—ã€‚', type:'speed' },
      { id:'smite', name:'éš•çŸ³', icon:'â˜„', description:'æ•µã®é§’1ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã‚­ãƒ³ã‚°ã«ã‚‚æœ‰åŠ¹ï¼‰ã€‚', type:'smite' },
      { id:'plague', name:'ç–«ç—…', icon:'ğŸ¦ ', description:'æŒ‡å®šã—ãŸãƒã‚¹ã‚’ä¸­å¿ƒã«3Ã—3ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆæ•µå‘³æ–¹å•ã‚ãšï¼‰ã€‚', type:'plague' },
      { id:'prayer', name:'ç¥ˆã‚Š', icon:'ğŸ™', description:'æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³ã€ç›¸æ‰‹ã®æœ€åˆã®ãƒã‚¤ãƒ¤ãƒ¼ã‚’ç„¡åŠ¹åŒ–ã€‚', type:'prayer' },
      { id:'terrain', name:'åœ°ã®åˆ©', icon:'â›°', description:'æŒ‡å®šãƒã‚¹1ã¤ã‚’æ•µã ã‘é€šã‚Œãªã„éšœå®³ç‰©ã«ã™ã‚‹ã€‚', type:'terrain' },
      { id:'divine', name:'é£¢é¤“', icon:'â˜ ', description:'æŒ‡å®šãƒã‚¹ã‚’ä¸­å¿ƒã«åå­—æ–¹å‘ï¼‹ä¸­å¿ƒã®æ•µé§’ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚', type:'divine' },
      { id:'boulder', name:'å¤©å¤‰åœ°ç•°', icon:'ğŸª¨', description:'ãƒ©ãƒ³ãƒ€ãƒ 3ãƒã‚¹ãŒæ•µã ã‘é€šã‚Œãªã„éšœå®³ç‰©ã«ãªã‚‹ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ãªã—ï¼‰ã€‚', type:'boulder' },
      { id:'escape', name:'é€ƒäº¡', icon:'ğŸƒ', description:'è‡ªåˆ†ã®ã‚­ãƒ³ã‚°ã‚’ä»»æ„ã®ç©ºããƒã‚¹ã«ç§»å‹•ã•ã›ã‚‹ã€‚', type:'escape' },
      { id:'swamp', name:'æ²¼', icon:'ğŸ•³', description:'ãƒ©ãƒ³ãƒ€ãƒ 2ãƒã‚¹ã«ç½ ã‚’è¨­ç½®ã€‚æ•µãŒè¸ã‚€ã¨1ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼†ãƒã‚¹è¡¨ç¤ºã€‚', type:'swamp' },
      { id:'barrier', name:'å®ˆè­·çµç•Œ', icon:'ğŸ›¡', description:'è‡ªè»ã‚­ãƒ³ã‚°ã¸ã®æ¬¡ã®ãƒ€ãƒ¡ãƒ¼ã‚¸1å›ã‚’ç„¡åŠ¹åŒ–ï¼ˆç›¸æ‰‹ã‚¿ãƒ¼ãƒ³ã¾ã§æŒç¶šï¼‰ã€‚', type:'barrier' },
      { id:'chain', name:'ç¥æˆ', icon:'ğŸŒ©', description:'æ•µ1ä½“ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‹ãã®å‘¨å›²8ãƒã‚¹ã®æ•µã«ã‚‚1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚', type:'chain' },
      { id:'timestop', name:'æ··ä¹±', icon:'ğŸ’«', description:'æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³ã€ç›¸æ‰‹ã¯é§’ã‚’å‹•ã‹ã›ãªã„ï¼ˆãƒã‚¤ãƒ¤ãƒ¼ä½¿ç”¨ã¯å¯ï¼‰ã€‚', type:'timestop' },
      { id:'force', name:'ãƒ•ã‚©ãƒ¼ã‚¹ã®å°ã', icon:'âœ¨', description:'ã‚­ãƒ³ã‚°ã¨åŸä»¥å¤–ã®è‡ªè»é§’1ä½“ã‚’é¸ã³ã€ä»»æ„ã®ç©ºããƒã‚¹ã¸ãƒ¯ãƒ¼ãƒ—ç§»å‹•ï¼ˆæ”»æ’ƒä¸å¯ï¼ç½ ã¯ç™ºå‹•ï¼éšœå®³ç‰©ã«ã¯ä¹—ã‚Œãªã„ï¼‰ã€‚', type:'force' },
    ];

    function getMaxHpByType(type){
      switch(type){
        case PieceType.KING: return HP_KING;
        case PieceType.FOOTMAN: return HP_FOOTMAN;
        case PieceType.KNIGHT: return HP_KNIGHT;
        case PieceType.ARCHER: return HP_ARCHER;
        case PieceType.MONK: return HP_MONK;
        case PieceType.MAGE: return HP_MAGE;
        case PieceType.ASSASSIN: return HP_ASSASSIN;
        case PieceType.SHIELD: return HP_SHIELD;
        case PieceType.CASTLE: return HP_CASTLE;
        default: return 1;
      }
    }

    function shuffle(array){
      for(let i=array.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [array[i],array[j]]=[array[j],array[i]];
      }
    }

    function initGame(mode='cpu'){
      gameMode=mode;
      cpuPlayer = (gameMode==='cpu') ? 'black' : null;

      state.board=[];
      for(let y=0;y<BOARD_SIZE;y++){
        const row=[];
        for(let x=0;x<BOARD_SIZE;x++) row.push(null);
        state.board.push(row);
      }

      let positions=[];
      for(let y=0;y<BOARD_SIZE;y++) for(let x=0;x<BOARD_SIZE;x++) positions.push({x,y});
      shuffle(positions);

      const piecesToPlace=[];
      piecesToPlace.push({player:'black', type:PieceType.KING});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'black', type:PieceType.KNIGHT});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'black', type:PieceType.FOOTMAN});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'black', type:PieceType.ARCHER});
      piecesToPlace.push({player:'black', type:PieceType.MONK});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'black', type:PieceType.SHIELD});
      piecesToPlace.push({player:'black', type:PieceType.MAGE});
      piecesToPlace.push({player:'black', type:PieceType.ASSASSIN});

      piecesToPlace.push({player:'white', type:PieceType.KING});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'white', type:PieceType.KNIGHT});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'white', type:PieceType.FOOTMAN});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'white', type:PieceType.ARCHER});
      piecesToPlace.push({player:'white', type:PieceType.MONK});
      for(let i=0;i<2;i++) piecesToPlace.push({player:'white', type:PieceType.SHIELD});
      piecesToPlace.push({player:'white', type:PieceType.MAGE});
      piecesToPlace.push({player:'white', type:PieceType.ASSASSIN});

      for(let i=0;i<piecesToPlace.length;i++){
        const pos=positions[i];
        const spec=piecesToPlace[i];
        state.board[pos.y][pos.x]={ player:spec.player, type:spec.type, hp:getMaxHpByType(spec.type) };
      }

      placeCastlesAdjacent();

      state.decks.white=[]; state.decks.black=[];
      CARD_TEMPLATES.forEach(t=>{ state.decks.white.push({...t}); state.decks.black.push({...t}); });
      shuffle(state.decks.white); shuffle(state.decks.black);

      state.hands.white=[]; state.hands.black=[];
      state.discard=[];
      state.activeEffect=null;
      state.targeting=null;
      state.prayerShield={white:false, black:false};
      state.terrainBlocks=[];
      state.traps=[];
      state.aoePreview=[];
      state.winner=null;
      state.log=[];
      state.turnCount=1;
      state.currentPlayer='white';
      state.selectedCell=null;
      state.validMoves=[];
      state.cardPlayedThisTurn=false;
      state.guardBarrier={white:null, black:null};
      state.timeStop={white:null, black:null};
      state.cardLock={white:true, black:false}; // ç™½1ã‚¿ãƒ¼ãƒ³ç›®ãƒ­ãƒƒã‚¯
      state.turnActionCells=[];
      state.lastTurnHighlight=null;
      state.lastReplayText='';
      state.turnStartLogIndex=0;
      state.usedCardThisTurn=null;

      for(let i=0;i<MAX_HAND;i++){ drawCard('white'); drawCard('black'); }

      if(gameMode==='cpu') logMessage('ã‚²ãƒ¼ãƒ é–‹å§‹ã€‚ã€CPUæˆ¦ã€‘ç™½ï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ï¼ é»’ï¼CPU');
      else logMessage('ã‚²ãƒ¼ãƒ é–‹å§‹ã€‚ã€å¯¾äººæˆ¦ã€‘ç™½ï¼P1 ï¼ é»’ï¼P2');
      logMessage('å…ˆè¡Œï¼ˆç™½ï¼‰ã¯1ã‚¿ãƒ¼ãƒ³ç›®ã®ã¿ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ä¸å¯ã€‚');
      logMessage('ç™½ã®ã‚¿ãƒ¼ãƒ³ã€‚');
      state.turnStartLogIndex = state.log.length;

      updateModeButtons();
      renderAll();

      if(!state.winner && gameMode==='cpu' && state.currentPlayer===cpuPlayer){
        setTimeout(cpuTurn,400);
      }
    }

    function placeCastlesAdjacent(){
      ['white','black'].forEach(player=>{
        const kingPos=findKing(player);
        if(!kingPos) return;

        const dirs=[
          {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
          {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1},
        ];
        for(const d of dirs){
          const nx=kingPos.x+d.dx, ny=kingPos.y+d.dy;
          if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
          if(!state.board[ny][nx]){
            state.board[ny][nx]={player, type:PieceType.CASTLE, hp:HP_CASTLE};
            return;
          }
        }
      });
    }

    function updateModeButtons(){
      const cpuBtn=document.getElementById('modeCpuBtn');
      const pvpBtn=document.getElementById('modePvpBtn');
      cpuBtn.classList.toggle('active', gameMode==='cpu');
      pvpBtn.classList.toggle('active', gameMode==='pvp');
    }

    function drawCard(player){
      const deck=state.decks[player];
      if(!deck||deck.length===0) return;
      if(state.hands[player].length>=MAX_HAND) return;
      const card=deck.pop();
      state.hands[player].push(card);
      logMessage(`${player==='white'?'ç™½':'é»’'}ãŒã€Œ${card.name}ã€ã‚’ãƒ‰ãƒ­ãƒ¼ã€‚`);
    }

    function glyphFor(piece){
      switch(piece.type){
        case PieceType.KING: return 'â™”';
        case PieceType.KNIGHT: return 'â™';
        case PieceType.FOOTMAN: return 'â™™';
        case PieceType.ARCHER: return 'â¹';
        case PieceType.CASTLE: return 'â™–';
        case PieceType.MONK: return 'âœ';
        case PieceType.SHIELD: return 'ğŸ›¡';
        case PieceType.MAGE: return 'â‚';
        case PieceType.ASSASSIN: return 'âœ§';
        default: return '?';
      }
    }

    function hpKanji(piece){
      if(!piece||piece.type!==PieceType.KING) return '';
      if(piece.hp>=5) return 'å¯¿';
      if(piece.hp>=3) return 'æ „';
      if(piece.hp===2) return 'è¡°';
      if(piece.hp===1) return 'æ»…';
      return '';
    }

    function renderBoard(){
      const boardDiv=document.getElementById('board');
      boardDiv.innerHTML='';

      boardDiv.classList.remove('white-turn','black-turn');
      boardDiv.classList.add(state.currentPlayer==='white'?'white-turn':'black-turn');

      for(let y=0;y<BOARD_SIZE;y++){
        for(let x=0;x<BOARD_SIZE;x++){
          const cellDiv=document.createElement('div');
          cellDiv.classList.add('cell');
          cellDiv.classList.add((x+y)%2===1?'dark':'light');
          cellDiv.dataset.x=x; cellDiv.dataset.y=y;

          const piece=state.board[y][x];

          const block=state.terrainBlocks.find(b=>b.x===x&&b.y===y);
          if(block){
            if(block.blockedFor==='white') cellDiv.classList.add('terrain-block-white');
            else if(block.blockedFor==='black') cellDiv.classList.add('terrain-block-black');
            else if(block.blockedFor==='both') cellDiv.classList.add('stone-block');
            const sym=document.createElement('span');
            sym.classList.add('cell-symbol');
            sym.textContent = block.kind==='terrain' ? 'â›°' : 'ğŸª¨';
            cellDiv.appendChild(sym);
          }

          const trap=state.traps.find(t=>t.x===x&&t.y===y&&t.revealed);
          if(trap){
            cellDiv.classList.add('trap-revealed');
            const sym=document.createElement('span');
            sym.classList.add('cell-symbol');
            sym.textContent='ğŸ•³';
            cellDiv.appendChild(sym);
          }

          if(piece){
            const span=document.createElement('span');
            span.textContent=glyphFor(piece);
            const cls=piece.player==='white'?'white-piece':'black-piece';
            span.classList.add(cls);
            if(piece.type===PieceType.KING) span.classList.add('king');
            if(piece.type===PieceType.CASTLE) span.classList.add('castle');
            if(piece.type===PieceType.MAGE) span.classList.add('mage');
            cellDiv.appendChild(span);

            const hpSpan=document.createElement('span');
            let labelText=String(piece.hp);
            if(piece.type===PieceType.KING){
              const label=hpKanji(piece);
              labelText=`${label}${piece.hp}`;
              if(piece.hp>=4) hpSpan.classList.add('hp-high');
              else if(piece.hp>=3) hpSpan.classList.add('hp-mid');
              else hpSpan.classList.add('hp-low');
            }
            hpSpan.textContent=labelText;
            hpSpan.classList.add('hp-label');
            cellDiv.appendChild(hpSpan);

            if(piece.type===PieceType.KING){
              const player=piece.player;
              const gb=state.guardBarrier[player];
              if(gb&&gb.active&&gb.hitsLeft>0){
                const shieldIcon=document.createElement('span');
                shieldIcon.classList.add('buff-symbol','buff-symbol-shield');
                shieldIcon.textContent='ğŸ›¡';
                cellDiv.appendChild(shieldIcon);
              }
              if(state.prayerShield[player]){
                const prayerIcon=document.createElement('span');
                prayerIcon.classList.add('buff-symbol','buff-symbol-prayer','buff-symbol-left');
                prayerIcon.textContent='ğŸ™';
                cellDiv.appendChild(prayerIcon);
              }
            }
          }

          if(state.selectedCell && state.selectedCell.x===x && state.selectedCell.y===y) cellDiv.classList.add('selected');
          if(state.validMoves.some(m=>m.x===x&&m.y===y)) cellDiv.classList.add('highlight');

          if(state.aoePreview.some(a=>a.x===x&&a.y===y)){
            cellDiv.classList.add(state.currentPlayer==='white'?'aoe-preview-white':'aoe-preview-black');
          }

          if(state.lastTurnHighlight && state.lastTurnHighlight.cells.some(c=>c.x===x&&c.y===y)){
            cellDiv.classList.add(state.lastTurnHighlight.player==='white'?'last-turn-white':'last-turn-black');
          }

          cellDiv.addEventListener('click', onCellClick);
          boardDiv.appendChild(cellDiv);
        }
      }
    }

    function renderHandFor(player, containerId){
      const handDiv=document.getElementById(containerId);
      handDiv.innerHTML='';
      const hand=state.hands[player];
      if(hand.length===0){ handDiv.textContent='æ‰‹æœ­ãªã—'; return; }

      const isCpuSide=(gameMode==='cpu' && player===cpuPlayer);
      const isCurrentTurn=(state.currentPlayer===player);

      hand.forEach((card,index)=>{
        const cardDiv=document.createElement('div');
        cardDiv.classList.add('card');

        const clickable =
          !state.winner &&
          !state.cardPlayedThisTurn &&
          isCurrentTurn &&
          !isCpuSide &&
          !isCardLocked(player);

        if(!clickable) cardDiv.classList.add('disabled');

        let extra='';
        if(isCardLocked(player) && player==='white' && state.turnCount===1){
          extra='<br><small>â€» å…ˆè¡Œ1ã‚¿ãƒ¼ãƒ³ç›®ã¯ä½¿ç”¨ä¸å¯</small>';
        }

        const icon = card.icon ? card.icon + ' ' : '';
        cardDiv.innerHTML = `<strong>${icon}${card.name}</strong><br><small>${card.description}</small>${extra}`;

        if(clickable) cardDiv.addEventListener('click',()=>playCardFor(player,index));
        handDiv.appendChild(cardDiv);
      });
    }

    function renderEffectsBar(){
      const bar=document.getElementById('effectsBar');
      function iconsFor(player){
        const icons=[];
        if(state.prayerShield[player]) icons.push('ğŸ™ ç¥ˆã‚Šï¼šæ¬¡ã®ãƒã‚¤ãƒ¤ãƒ¼å°å°');
        const gb=state.guardBarrier[player];
        if(gb && gb.active && gb.hitsLeft>0) icons.push('ğŸ›¡ å®ˆè­·çµç•Œï¼šãƒ€ãƒ¡ãƒ¼ã‚¸1å›ç„¡åŠ¹');
        const ts=state.timeStop[player];
        if(ts && ts.active) icons.push('ğŸ’« æ··ä¹±ï¼šé§’ç§»å‹•ä¸å¯');
        const hasSwamp=state.traps.some(t=>t.owner===player && !t.revealed);
        if(hasSwamp) icons.push('ğŸ•³ æ²¼ï¼šç½ è¨­ç½®ä¸­');
        return icons;
      }
      const wIcons=iconsFor('white');
      const bIcons=iconsFor('black');

      bar.innerHTML = `
        <div class="effects-side">
          <div class="effects-label">ç™½ã®çŠ¶æ…‹</div>
          <div class="effects-icons">${ wIcons.length ? wIcons.map(i=>`<span>${i}</span>`).join('') : '' }</div>
        </div>
        <div class="effects-side">
          <div class="effects-label">é»’ã®çŠ¶æ…‹</div>
          <div class="effects-icons">${ bIcons.length ? bIcons.map(i=>`<span>${i}</span>`).join('') : '' }</div>
        </div>
      `;
    }

    /* âœ… ç›¤é¢ä¸Šã«ã€ã“ã®ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º */
function renderBoardUsedOverlay(){
  const el = document.getElementById('boardUsedOverlay');
  const info = state.usedCardThisTurn;

  // ã‚¯ãƒ©ã‚¹åˆæœŸåŒ–
  el.classList.remove('overlay-empty', 'overlay-white', 'overlay-black');

  // ã¾ã ã“ã®ã‚¿ãƒ¼ãƒ³ã«ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ãªã„å ´åˆ
  if (!info) {
    el.classList.add('overlay-empty');
    el.textContent = 'ä½¿ç”¨ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ï¼šãªã—';
    return;
  }

  // ã©ã¡ã‚‰ã®é™£å–¶ãŒä½¿ã£ãŸã‹ã§æ è‰²å¤‰æ›´
  el.classList.add(info.player === 'white' ? 'overlay-white' : 'overlay-black');

  const side = info.player === 'white' ? 'ç™½' : 'é»’';
  const icon = info.icon || 'â˜…';

  // ä½¿ç”¨ã—ãŸãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰åã‚’è¡¨ç¤º
  el.textContent = `ä½¿ç”¨ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ï¼š${icon} ${info.name}ï¼ˆ${side}ï¼‰`;
}


    function renderHayerStatus(){
      function build(containerId, player){
        const div=document.getElementById(containerId);
        div.innerHTML='';
        CARD_TEMPLATES.forEach(t=>{
          const pill=document.createElement('div');
          pill.classList.add('hayer-pill');
          pill.textContent=(t.icon ? t.icon+' ' : '') + t.name;

          const used =
            state.discard.some(c=>c.id===t.id && c.owner===player) ||
            (!state.decks[player].some(c=>c.id===t.id) && !state.hands[player].some(c=>c.id===t.id));

          if(used) pill.classList.add('used');
          div.appendChild(pill);
        });
      }
      build('hayerWhiteStatus','white');
      build('hayerBlackStatus','black');
    }

    function renderPhasePanel(){
      const panel=document.getElementById('phasePanel');

      if(state.winner){
        let title='', sub='';
        if(state.winner==='draw'){
          title='å¼•ãåˆ†ã‘';
          sub='ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‹ã‚‰æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚';
        }else{
          const isCpu=(gameMode==='cpu');
          if(state.winner==='white') title = isCpu ? 'ç™½ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ã®å‹åˆ©ï¼' : 'ç™½ï¼ˆP1ï¼‰ã®å‹åˆ©ï¼';
          else title = isCpu ? (cpuPlayer==='black' ? 'é»’ï¼ˆCPUï¼‰ã®å‹åˆ©ï¼' : 'é»’ã®å‹åˆ©ï¼') : 'é»’ï¼ˆP2ï¼‰ã®å‹åˆ©ï¼';
          sub='ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨æ–°ã—ã„å¯¾å±€ãŒå§‹ã¾ã‚Šã¾ã™ã€‚';
        }
        panel.innerHTML=`
          <div class="phase-card phase-result ${state.winner==='white'?'phase-white':state.winner==='black'?'phase-black':''}">
            <div class="phase-main">${title}</div>
            <div class="phase-sub">${sub}</div>
          </div>`;
        return;
      }

      const remaining=Math.max(0, MAX_TURNS - state.turnCount + 1);
      const cp=state.currentPlayer;
      const hasHand=state.hands[cp].length>0;
      const locked=isCardLocked(cp);
      const playerLabel=(gameMode==='cpu')
        ? (cp==='white' ? 'ç™½ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰' : 'é»’ï¼ˆCPUï¼‰')
        : (cp==='white' ? 'ç™½ï¼ˆP1ï¼‰' : 'é»’ï¼ˆP2ï¼‰');

      let phaseTitle='', phaseSub='';
      if(isPlayerTimeStopped(cp)){
        phaseTitle=`${playerLabel}ï¼šæ··ä¹±ä¸­ï¼ˆé§’ç§»å‹•ä¸å¯ï¼‰`;
        phaseSub='ã“ã®ã‚¿ãƒ¼ãƒ³ã¯ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™ã€‚';
      }else if(hasHand && !state.cardPlayedThisTurn && !locked){
        phaseTitle=`${playerLabel} ã®ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ãƒ•ã‚§ãƒ¼ã‚º`;
        phaseSub='ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã‚“ã§ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚';
      }else{
        phaseTitle=`${playerLabel} ã®é§’ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º`;
        phaseSub='é§’ã‚’1ä½“é¸ã‚“ã§ç§»å‹•ã•ã›ã¦ãã ã•ã„ã€‚å‹•ã‹ãªã„å ´åˆã¯ã‚¿ãƒ¼ãƒ³çµ‚äº†ãƒœã‚¿ãƒ³ã§ã‚‚OKã€‚';
      }
      const turnInfo=`ã‚¿ãƒ¼ãƒ³ ${state.turnCount}/${MAX_TURNS}ï¼ˆæ®‹ã‚Š ${remaining}ï¼‰`;

      panel.innerHTML=`
        <div class="phase-card ${cp==='white'?'phase-white':'phase-black'}">
          <div class="phase-main">${phaseTitle}</div>
          <div class="phase-sub">${phaseSub}</div>
          <div class="phase-sub">${turnInfo}</div>
        </div>`;
    }

    function renderBattlePanel(){
      const bw=document.getElementById('battleWhite');
      const bb=document.getElementById('battleBlack');

      const wc=countPieces('white');
      const bc=countPieces('black');
      const wKing=findKing('white');
      const bKing=findKing('black');
      const wKingHp=wKing?state.board[wKing.y][wKing.x].hp:0;
      const bKingHp=bKing?state.board[bKing.y][bKing.x].hp:0;

      const wHayerRem=state.decks.white.length + state.hands.white.length;
      const bHayerRem=state.decks.black.length + state.hands.black.length;

      bw.innerHTML=`
        <div class="battle-side-title">ç™½</div>
        <div>é§’æ•°ï¼š${wc}</div>
        <div>ã‚­ãƒ³ã‚°HPï¼š${wKing ? wKingHp : 'æ’ƒç ´'}</div>
        <div>ãƒã‚¤ãƒ¤ãƒ¼æ®‹ã‚Šï¼š${wHayerRem}</div>
      `;
      bb.innerHTML=`
        <div class="battle-side-title">é»’</div>
        <div>é§’æ•°ï¼š${bc}</div>
        <div>ã‚­ãƒ³ã‚°HPï¼š${bKing ? bKingHp : 'æ’ƒç ´'}</div>
        <div>ãƒã‚¤ãƒ¤ãƒ¼æ®‹ã‚Šï¼š${bHayerRem}</div>
      `;
    }

    function renderReplayPanel(){
      const body=document.getElementById('replayBody');
      body.textContent = state.lastReplayText || 'ã¾ã å‰ã‚¿ãƒ¼ãƒ³ã®æƒ…å ±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚';
    }

    /* âœ… ã‚·ãƒ¼ãƒ³ã«åˆã£ãŸã‚¤ãƒ©ã‚¹ãƒˆè¡¨ç¤ºï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†ãƒœã‚¿ãƒ³ã®ä¸‹ï¼‰ */
    function updateSceneImage(){
      const img=document.getElementById('sceneImage');
      if(!img) return;

      let src='battle.png';
      if(state.winner==='white') src='white.png';
      else if(state.winner==='black') src='black.png';
      else if(state.winner==='draw') src='title.png';
      else src='battle.png';

      if(img.getAttribute('src') !== src) img.setAttribute('src', src);
    }

    function renderUI(){
      renderPhasePanel();
      renderHandFor('white','handWhite');
      renderHandFor('black','handBlack');
      renderBattlePanel();
      renderReplayPanel();
      renderEffectsBar();
      renderBoardUsedOverlay();
      renderHayerStatus();
      updateSceneImage();

      const logDiv=document.getElementById('log');
      logDiv.innerHTML = state.log.map(line=>`<div>${line}</div>`).join('');
      logDiv.scrollTop = logDiv.scrollHeight;

      const endBtn=document.getElementById('endTurnBtn');
      const isCpuTurn=(gameMode==='cpu' && state.currentPlayer===cpuPlayer);
      endBtn.disabled = !!state.winner || isCpuTurn;
    }

    function renderAll(){ renderBoard(); renderUI(); }

    function onCellClick(e){
      if(state.winner) return;
      if(gameMode==='cpu' && state.currentPlayer===cpuPlayer) return;

      const x=parseInt(e.currentTarget.dataset.x,10);
      const y=parseInt(e.currentTarget.dataset.y,10);
      const cellPiece=state.board[y][x];

      if(!state.targeting) state.aoePreview=[];

      if(state.targeting){
        handleTargetingClick(x,y,cellPiece);
        return;
      }

      const current=state.currentPlayer;
      if(cellPiece && cellPiece.player===current){
        state.selectedCell={x,y};
        state.validMoves=getValidMoves(x,y);
      }else if(state.selectedCell){
        const valid=state.validMoves.some(m=>m.x===x&&m.y===y);
        if(valid){
          movePiece(state.selectedCell.x,state.selectedCell.y,x,y);
          state.selectedCell=null;
          state.validMoves=[];
        }else{
          state.selectedCell=null;
          state.validMoves=[];
        }
      }
      renderAll();
    }

    function isSquareBlockedForPlayer(x,y,player){
      return state.terrainBlocks.some(b=>b.x===x&&b.y===y&&(b.blockedFor===player||b.blockedFor==='both'));
    }
    function speedActiveFor(player){
      return (state.activeEffect && state.activeEffect.type==='speed' && state.activeEffect.player===player);
    }
    function isPlayerTimeStopped(player){
      const info=state.timeStop[player];
      return info && info.active;
    }
    function isCardLocked(player){ return state.cardLock && state.cardLock[player]; }

    function findKing(player){
      for(let y=0;y<BOARD_SIZE;y++){
        for(let x=0;x<BOARD_SIZE;x++){
          const p=state.board[y][x];
          if(p && p.player===player && p.type===PieceType.KING) return {x,y};
        }
      }
      return null;
    }

    function countPieces(player){
      let count=0;
      for(let y=0;y<BOARD_SIZE;y++){
        for(let x=0;x<BOARD_SIZE;x++){
          const p=state.board[y][x];
          if(p && p.player===player) count++;
        }
      }
      return count;
    }

    function pieceName(piece){
      switch(piece.type){
        case PieceType.KING: return 'ã‚­ãƒ³ã‚°';
        case PieceType.KNIGHT: return 'é¨é¦¬';
        case PieceType.FOOTMAN: return 'æ­©å…µ';
        case PieceType.ARCHER: return 'å¼“å…µ';
        case PieceType.CASTLE: return 'åŸ';
        case PieceType.MONK: return 'åƒ§ä¾¶';
        case PieceType.SHIELD: return 'ç›¾å…µ';
        case PieceType.MAGE: return 'é­”å°å£«';
        case PieceType.ASSASSIN: return 'æš—æ®ºè€…';
        default: return 'ï¼Ÿ';
      }
    }

    function recordCellAction(x,y){
      if(x<0||x>=BOARD_SIZE||y<0||y>=BOARD_SIZE) return;
      if(!state.turnActionCells) state.turnActionCells=[];
      if(!state.turnActionCells.some(c=>c.x===x&&c.y===y)) state.turnActionCells.push({x,y});
    }

    function getValidMoves(x,y){
      const piece=state.board[y][x];
      if(!piece) return [];
      const moves=[];
      const enemy = piece.player==='white'?'black':'white';
      const speedOn = speedActiveFor(piece.player);

      if(piece.player===state.currentPlayer && isPlayerTimeStopped(piece.player)) return [];
      if(piece.type===PieceType.KING || piece.type===PieceType.CASTLE) return [];

      if(piece.type===PieceType.MONK){
        const maxRange=speedOn?3:2;
        const directions=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
        for(const dir of directions){
          for(let step=1;step<=maxRange;step++){
            const nx=x+dir.dx*step, ny=y+dir.dy*step;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) break;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) break;
            const target=state.board[ny][nx];
            if(target){
              if(target.player===piece.player) break;
              if(target.player===enemy){ moves.push({x:nx,y:ny}); break; }
            }else moves.push({x:nx,y:ny});
          }
        }
        return moves;
      }

      if(piece.type===PieceType.KNIGHT){
        const maxRange=speedOn?3:2;
        const directions=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
        for(const dir of directions){
          for(let step=1;step<=maxRange;step++){
            const nx=x+dir.dx*step, ny=y+dir.dy*step;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) break;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) break;
            const target=state.board[ny][nx];
            if(target){
              if(target.player===piece.player) break;
              if(target.player===enemy){ moves.push({x:nx,y:ny}); break; }
            }else moves.push({x:nx,y:ny});
          }
        }
        return moves;
      }

      if(piece.type===PieceType.FOOTMAN){
        if(!speedOn){
          const directions=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
          for(const dir of directions){
            const nx=x+dir.dx, ny=y+dir.dy;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) continue;
            const target=state.board[ny][nx];
            if(target && target.player===piece.player) continue;
            moves.push({x:nx,y:ny});
          }
          return moves;
        }
        for(let dx=-2;dx<=2;dx++){
          for(let dy=-2;dy<=2;dy++){
            if(dx===0 && dy===0) continue;
            const nx=x+dx, ny=y+dy;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) continue;
            const target=state.board[ny][nx];
            if(target && target.player===piece.player) continue;
            moves.push({x:nx,y:ny});
          }
        }
        return moves;
      }

      if(piece.type===PieceType.ARCHER){
        const deltas = !speedOn
          ? [{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2},{dx:2,dy:2},{dx:2,dy:-2},{dx:-2,dy:2},{dx:-2,dy:-2}]
          : [{dx:3,dy:0},{dx:-3,dy:0},{dx:0,dy:3},{dx:0,dy:-3},{dx:3,dy:3},{dx:3,dy:-3},{dx:-3,dy:3},{dx:-3,dy:-3}];
        for(const d of deltas){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
          if(isSquareBlockedForPlayer(nx,ny,piece.player)) continue;
          const target=state.board[ny][nx];
          if(target && target.player===piece.player) continue;
          moves.push({x:nx,y:ny});
        }
        return moves;
      }

      if(piece.type===PieceType.SHIELD){
        const maxRange=speedOn?2:1;
        const directions=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        for(const dir of directions){
          for(let step=1;step<=maxRange;step++){
            const nx=x+dir.dx*step, ny=y+dir.dy*step;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) break;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) break;
            const target=state.board[ny][nx];
            if(target){
              if(target.player===piece.player) break;
              if(target.player===enemy){ moves.push({x:nx,y:ny}); break; }
            }else moves.push({x:nx,y:ny});
          }
        }
        return moves;
      }

      if(piece.type===PieceType.MAGE){
        const deltas=[{dx:1,dy:2},{dx:2,dy:1},{dx:-1,dy:2},{dx:-2,dy:1},{dx:1,dy:-2},{dx:2,dy:-1},{dx:-1,dy:-2},{dx:-2,dy:-1}];
        const scale=speedOn?2:1;
        for(const d of deltas){
          const nx=x+d.dx*scale, ny=y+d.dy*scale;
          if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
          if(isSquareBlockedForPlayer(nx,ny,piece.player)) continue;
          const target=state.board[ny][nx];
          if(target && target.player===piece.player) continue;
          moves.push({x:nx,y:ny});
        }
        return moves;
      }

      if(piece.type===PieceType.ASSASSIN){
        const maxRange=speedOn?3:2;
        const directions=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];

        for(const dir of directions){
          for(let step=1;step<=maxRange;step++){
            const nx=x+dir.dx*step, ny=y+dir.dy*step;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) break;
            if(isSquareBlockedForPlayer(nx,ny,piece.player)) break;
            const target=state.board[ny][nx];
            if(target){
              if(target.player===piece.player) break;
              if(target.player===enemy){ moves.push({x:nx,y:ny}); break; }
            }else moves.push({x:nx,y:ny});
          }
        }

        for(const dir of directions){
          const landX=x+dir.dx*2, landY=y+dir.dy*2;
          if(landX<0||landX>=BOARD_SIZE||landY<0||landY>=BOARD_SIZE) continue;
          if(isSquareBlockedForPlayer(landX,landY,piece.player)) continue;
          const landPiece=state.board[landY][landX];
          if(landPiece && landPiece.player===piece.player) continue;
          moves.push({x:landX,y:landY});
        }
        return moves;
      }

      return moves;
    }

    function applyDamage(x,y,amount){
      const piece=state.board[y][x];
      if(!piece) return false;
      recordCellAction(x,y);

      if(piece.type===PieceType.KING){
        const info=state.guardBarrier[piece.player];
        if(info && info.active && info.hitsLeft>0){
          info.hitsLeft--;
          logMessage(`${piece.player==='white'?'ç™½':'é»’'}ã®ã‚­ãƒ³ã‚°ã¯å®ˆè­·çµç•Œã«å®ˆã‚‰ã‚Œã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãªã‹ã£ãŸã€‚`);
          if(info.hitsLeft<=0) info.active=false;
          return false;
        }
      }

      playSfx('attack');
      piece.hp -= amount;
      logMessage(`${piece.player==='white'?'ç™½':'é»’'}ã®${pieceName(piece)}ãŒ${amount}ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚ï¼ˆæ®‹ã‚ŠHP: ${piece.hp}ï¼‰`);

      if(piece.hp<=0){
        state.board[y][x]=null;
        logMessage(`${piece.player==='white'?'ç™½':'é»’'}ã®${pieceName(piece)}ãŒå€’ã‚ŒãŸã€‚`);
        checkAnnihilationVictory();
        return true;
      }
      return false;
    }

    function checkTrapAt(x,y,piece){
      const trap=state.traps.find(t=>t.x===x&&t.y===y&&!t.revealed);
      if(!trap) return;
      if(piece.player===trap.owner) return;

      logMessage('æ²¼ã®ç½ ãŒç™ºå‹•ï¼è¸ã‚“ã é§’ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚');
      state.aoePreview=[{x,y}];
      recordCellAction(x,y);
      applyDamage(x,y,1);
      trap.revealed=true;
    }

    function healAdjacentByMonk(player){
      for(let y=0;y<BOARD_SIZE;y++){
        for(let x=0;x<BOARD_SIZE;x++){
          const p=state.board[y][x];
          if(!p||p.player!==player||p.type!==PieceType.MONK) continue;

          const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}];
          dirs.forEach(d=>{
            const nx=x+d.dx, ny=y+d.dy;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) return;
            const target=state.board[ny][nx];
            if(!target||target.player!==player) return;

            const maxHp=getMaxHpByType(target.type);
            if(target.hp<maxHp){
              target.hp++;
              logMessage(`${player==='white'?'ç™½':'é»’'}ã®åƒ§ä¾¶ãŒ${pieceName(target)}ã‚’å›å¾©ã€‚ï¼ˆHP: ${target.hp}ï¼‰`);
            }
          });
        }
      }
    }

    function movePiece(fromX,fromY,toX,toY){
      if(state.winner) return;

      const current=state.currentPlayer;
      const handHasCard=state.hands[current].length>0;

      if(!state.cardPlayedThisTurn && handHasCard && !isCardLocked(current)){
        logMessage('ã“ã®ã‚¿ãƒ¼ãƒ³ã¯å…ˆã«ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’1æšä½¿ã£ã¦ãã ã•ã„ã€‚');
        renderAll(); return;
      }

      const piece=state.board[fromY][fromX];
      if(!piece) return;

      const target=state.board[toY][toX];
      let moved=false;

      if(target && target.player!==piece.player){
        const died = applyDamage(toX,toY,1);
        if(died){
          state.board[toY][toX]=piece;
          state.board[fromY][fromX]=null;
          moved=true;
        }else{
          logMessage('æ”»æ’ƒã—ãŸãŒæ•µã¯ã¾ã ç«‹ã£ã¦ã„ã‚‹ã€‚ãƒã‚¹ã«ã¯å…¥ã‚Œãªã„ã€‚');
        }
      }else{
        state.board[toY][toX]=piece;
        state.board[fromY][fromX]=null;
        moved=true;
      }

      if(moved){
        playSfx('move');
        recordCellAction(fromX,fromY);
        recordCellAction(toX,toY);
        checkTrapAt(toX,toY,state.board[toY][toX]);
      }

      if(state.activeEffect && state.activeEffect.type==='speed' && state.activeEffect.player===state.currentPlayer){
        state.activeEffect=null;
      }

      endTurn();
    }

    function playCardFor(player, handIndex){
      if(state.winner) return;
      if(state.targeting) return;
      if(state.currentPlayer!==player) return;

      if(isCardLocked(player)){
        if(player==='white' && state.turnCount===1) logMessage('å…ˆè¡Œ1ã‚¿ãƒ¼ãƒ³ç›®ã¯ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ãˆã¾ã›ã‚“ã€‚');
        else logMessage('ã“ã®ã‚¿ãƒ¼ãƒ³ã¯ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ãˆã¾ã›ã‚“ã€‚');
        return;
      }

      const current=state.currentPlayer;
      const enemy=current==='white'?'black':'white';
      const hand=state.hands[current];
      const card=hand[handIndex];
      if(!card) return;

      if(state.cardPlayedThisTurn){
        logMessage('ã“ã®ã‚¿ãƒ¼ãƒ³ã¯ã™ã§ã«ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚');
        return;
      }
      state.cardPlayedThisTurn=true;
      playSfx('card');
      state.aoePreview=[];

      // âœ… ç›¤é¢ã«å‡ºã™ç”¨ï¼ˆç›¸æ‰‹ã‚‚è¦‹ãˆã‚‹ï¼‰
      state.usedCardThisTurn = { player: current, id: card.id, name: card.name, icon: card.icon || '' };

      // ç¥ˆã‚Šã§ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã‚‚ã€Œä½¿ã£ãŸã€äº‹å®Ÿã¯è¦‹ãˆã‚‹ï¼ˆè¡¨ç¤ºã¯æ®‹ã™ï¼‰
      if(state.prayerShield[current]){
        logMessage(`${current==='white'?'ç™½':'é»’'}ã®ã€Œ${card.name}ã€ã¯ã€ç›¸æ‰‹ã®ç¥ˆã‚Šã«ã‚ˆã‚Šç„¡åŠ¹åŒ–ã•ã‚ŒãŸã€‚`);
        state.prayerShield[current]=false;
        state.discard.push({ ...card, owner: current });
        hand.splice(handIndex,1);
        renderAll();
        return;
      }

      if(card.type==='speed'){
        state.activeEffect={type:'speed', player: current};
        logMessage(`${current==='white'?'ç™½':'é»’'}ã¯ã€Œ${card.name}ã€ã‚’ç™ºå‹•ã€‚ç§»å‹•æ€§èƒ½ãŒä¸€æ™‚çš„ã«å¼·åŒ–ã•ã‚Œã‚‹ã€‚`);
      }else if(card.type==='smite'){
        state.targeting={type:'smite'};
        logMessage(`ã€Œ${card.name}ã€ï¼šæ•µã®é§’ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆ2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰ã€‚`);
      }else if(card.type==='plague'){
        state.targeting={type:'plague'};
        logMessage(`ã€Œ${card.name}ã€ï¼šä¸­å¿ƒã«ã™ã‚‹ãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆæ•µå‘³æ–¹å•ã‚ãšï¼‰ã€‚`);
      }else if(card.type==='prayer'){
        state.prayerShield[enemy]=true;
        logMessage(`${current==='white'?'ç™½':'é»’'}ã¯ã€Œ${card.name}ã€ã‚’æ§ã’ãŸã€‚${enemy==='white'?'ç™½':'é»’'}ã®æ¬¡ã®ãƒã‚¤ãƒ¤ãƒ¼ã¯ç„¡åŠ¹åŒ–ã•ã‚Œã‚‹ã€‚`);
      }else if(card.type==='terrain'){
        state.targeting={type:'terrain'};
        logMessage(`ã€Œ${card.name}ã€ï¼šæ•µã ã‘é€šã‚Œãªã„ãƒã‚¹ã‚’1ã¤é¸ã‚“ã§ãã ã•ã„ã€‚`);
      }else if(card.type==='divine'){
        state.targeting={type:'divine'};
        logMessage(`ã€Œ${card.name}ã€ï¼šä¸­å¿ƒãƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆåå­—æ–¹å‘ã«æ”»æ’ƒï¼‰ã€‚`);
      }else if(card.type==='boulder'){
        logMessage(`ã€Œ${card.name}ã€ç™ºå‹•ã€‚ãƒ©ãƒ³ãƒ€ãƒ ãª3ãƒã‚¹ãŒæ•µã ã‘é€šã‚Œãªã„éšœå®³ç‰©ã«ãªã‚‹ã€‚`);
        dropRandomBoulders(3, current);
      }else if(card.type==='escape'){
        state.targeting={type:'escape'};
        logMessage(`ã€Œ${card.name}ã€ï¼šã‚­ãƒ³ã‚°ã®ç§»å‹•å…ˆãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆç©ºããƒã‚¹ï¼‰ã€‚`);
      }else if(card.type==='swamp'){
        placeRandomSwamp(current);
      }else if(card.type==='barrier'){
        state.guardBarrier[current]={active:true, hitsLeft:1};
        logMessage(`${current==='white'?'ç™½':'é»’'}ã¯ã€Œ${card.name}ã€ã‚’å±•é–‹ã€‚ã‚­ãƒ³ã‚°ã¸ã®æ¬¡ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’1å›é˜²ãã€‚`);
      }else if(card.type==='chain'){
        state.targeting={type:'chain'};
        logMessage(`ã€Œ${card.name}ã€ï¼šæ•µã®é§’ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆå‘¨å›²ã‚‚å·»ãè¾¼ã‚€ï¼‰ã€‚`);
      }else if(card.type==='timestop'){
        state.timeStop[enemy]={active:true};
        logMessage(`${current==='white'?'ç™½':'é»’'}ã¯ã€Œ${card.name}ã€ã‚’ç™ºå‹•ã€‚${enemy==='white'?'ç™½':'é»’'}ã¯æ¬¡ã®ã‚¿ãƒ¼ãƒ³é§’ã‚’å‹•ã‹ã›ãªã„ã€‚`);
      }else if(card.type==='force'){
        state.targeting={type:'force', from:null};
        logMessage('ã€Œãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãã€ï¼šã‚­ãƒ³ã‚°ã¨åŸä»¥å¤–ã®è‡ªè»é§’ã‚’1ã¤é¸ã‚“ã§ãã ã•ã„ã€‚');
      }

      state.discard.push({ ...card, owner: current });
      hand.splice(handIndex,1);
      renderAll();
    }

    function dropRandomBoulders(count, owner){
      const enemy=owner==='white'?'black':'white';
      let placed=0, tries=0;
      while(placed<count && tries<200){
        tries++;
        const x=Math.floor(Math.random()*BOARD_SIZE);
        const y=Math.floor(Math.random()*BOARD_SIZE);
        if(state.terrainBlocks.some(b=>b.x===x&&b.y===y)) continue;
        state.terrainBlocks.push({x,y,blockedFor:enemy,kind:'stone'});
        recordCellAction(x,y);
        placed++;
        logMessage(`å¤©å¤‰åœ°ç•°ã«ã‚ˆã‚Š (${x},${y}) ã«éšœå®³ç‰©ãŒç™ºç”Ÿã—ã€${enemy==='white'?'ç™½':'é»’'}ã ã‘é€šã‚Œãªããªã£ãŸã€‚`);
      }
    }

    function placeRandomSwamp(owner){
      let placed=0, tries=0;
      while(placed<2 && tries<200){
        tries++;
        const x=Math.floor(Math.random()*BOARD_SIZE);
        const y=Math.floor(Math.random()*BOARD_SIZE);
        if(state.traps.some(t=>t.x===x&&t.y===y)) continue;
        if(state.board[y][x]) continue;
        state.traps.push({x,y,owner,revealed:false});
        placed++;
      }
      if(placed>0) logMessage(`${owner==='white'?'ç™½':'é»’'}ã¯ã©ã“ã‹ã«${placed}ã¤ã®ã€Œæ²¼ã€ã‚’è¨­ç½®ã—ãŸâ€¦ã€‚`);
      else logMessage('æ²¼ã‚’è¨­ç½®ã§ãã‚‹å ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
    }

    function handleTargetingClick(x,y,cellPiece){
      const t=state.targeting;
      if(!t) return;

      const current=state.currentPlayer;
      const enemy=current==='white'?'black':'white';

      if(t.type==='smite'){
        if(!cellPiece || cellPiece.player===current){
          logMessage('éš•çŸ³ã¯ä¸ç™ºã«çµ‚ã‚ã£ãŸâ€¦ã€‚');
          state.aoePreview=[]; state.targeting=null; renderAll(); return;
        }
        logMessage('éš•çŸ³ãŒå‘½ä¸­ï¼ï¼ˆ2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰');
        state.aoePreview=[{x,y}];
        recordCellAction(x,y);
        applyDamage(x,y,2);
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='chain'){
        if(!cellPiece || cellPiece.player===current){
          logMessage('ç¥æˆã¯ä¸ç™ºã«çµ‚ã‚ã£ãŸâ€¦ã€‚');
          state.aoePreview=[]; state.targeting=null; renderAll(); return;
        }
        logMessage(`ã€Œç¥æˆã€ãŒç™ºå‹•ã€‚(${x},${y}) ã¨ãã®å‘¨å›²ã®æ•µã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`);
        const aoe=[];
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx=x+dx, ny=y+dy;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
            aoe.push({x:nx,y:ny});
            const p=state.board[ny][nx];
            if(p && p.player===enemy) applyDamage(nx,ny,1);
          }
        }
        aoe.forEach(c=>recordCellAction(c.x,c.y));
        state.aoePreview=aoe;
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='plague'){
        logMessage(`ã€Œç–«ç—…ã€ãŒç™ºå‹•ã€‚(${x},${y}) ã‚’ä¸­å¿ƒã«3Ã—3ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`);
        const aoe=[];
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx=x+dx, ny=y+dy;
            if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
            aoe.push({x:nx,y:ny});
            if(state.board[ny][nx]) applyDamage(nx,ny,1);
          }
        }
        aoe.forEach(c=>recordCellAction(c.x,c.y));
        state.aoePreview=aoe;
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='terrain'){
        if(state.board[y][x]){
          logMessage('åœ°ã®åˆ©ï¼šç©ºã„ã¦ã„ã‚‹ãƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚');
          return;
        }
        state.terrainBlocks.push({x,y,blockedFor:enemy,kind:'terrain'});
        recordCellAction(x,y);
        state.aoePreview=[{x,y}];
        logMessage(`ã€Œåœ°ã®åˆ©ã€ç™ºå‹•ï¼š${enemy==='white'?'ç™½':'é»’'}ã¯ (${x},${y}) ã«å…¥ã‚Œãªããªã£ãŸã€‚`);
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='divine'){
        logMessage(`ã€Œé£¢é¤“ã€ãŒç™ºå‹•ã€‚(${x},${y}) ã‚’ä¸­å¿ƒã«åå­—æ–¹å‘ã¸è£ããŒä¸‹ã‚‹ã€‚`);
        const dirs=[{dx:0,dy:0},{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
        const aoe=[];
        for(const d of dirs){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
          aoe.push({x:nx,y:ny});
          const p=state.board[ny][nx];
          if(p && p.player===enemy) applyDamage(nx,ny,1);
        }
        aoe.forEach(c=>recordCellAction(c.x,c.y));
        state.aoePreview=aoe;
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='escape'){
        const kingPos=findKing(current);
        if(!kingPos){
          logMessage('ã‚­ãƒ³ã‚°ãŒã„ãªã„ãŸã‚ã€Œé€ƒäº¡ã€ã¯ä½¿ãˆã¾ã›ã‚“ã€‚');
          state.targeting=null; state.aoePreview=[]; renderAll(); return;
        }
        if(state.board[y][x] || isSquareBlockedForPlayer(x,y,current)){
          logMessage('é€ƒäº¡å…ˆã¯éšœå®³ç‰©ã®ãªã„ç©ºããƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚');
          state.targeting=null; state.aoePreview=[]; renderAll(); return;
        }
        const king=state.board[kingPos.y][kingPos.x];
        recordCellAction(kingPos.x,kingPos.y);
        recordCellAction(x,y);
        state.board[kingPos.y][kingPos.x]=null;
        state.board[y][x]=king;
        state.aoePreview=[{x,y}];
        logMessage(`${current==='white'?'ç™½':'é»’'}ã®ã‚­ãƒ³ã‚°ãŒã€Œé€ƒäº¡ã€ã§ (${x},${y}) ã«ç§»å‹•ã—ãŸã€‚`);
        state.targeting=null; renderAll(); return;
      }

      if(t.type==='force'){
        if(!t.from){
          if(!cellPiece || cellPiece.player!==current || cellPiece.type===PieceType.KING || cellPiece.type===PieceType.CASTLE){
            logMessage('ãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãï¼šã‚­ãƒ³ã‚°ã¨åŸä»¥å¤–ã®è‡ªè»é§’ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚');
            return;
          }
          t.from={x,y};
          logMessage('ãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãï¼šç§»å‹•å…ˆã®ç©ºããƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚');
          return;
        }else{
          if(state.board[y][x]){
            logMessage('ãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãï¼šç©ºããƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚');
            return;
          }
          // â˜… ä¿®æ­£ï¼šéšœå®³ç‰©ãƒã‚§ãƒƒã‚¯ã‚’æ­£ã—ãå®Ÿè£…
          if (isSquareBlockedForPlayer(x, y, current)) {
            logMessage('ãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãï¼šéšœå®³ç‰©ã®ãƒã‚¹ã«ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚');
            return;
          }
          const from=t.from;
          const piece=state.board[from.y][from.x];
          if(!piece){ state.targeting=null; state.aoePreview=[]; renderAll(); return; }

          recordCellAction(from.x,from.y);
          recordCellAction(x,y);

          state.board[from.y][from.x]=null;
          state.board[y][x]=piece;
          state.aoePreview=[{x,y}];
          logMessage(`${current==='white'?'ç™½':'é»’'}ã®${pieceName(piece)}ãŒã€Œãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãã€ã§ (${x},${y}) ã«ç¬é–“ç§»å‹•ã—ãŸã€‚`);
          checkTrapAt(x,y,piece);

          state.targeting=null; renderAll(); return;
        }
      }

      state.targeting=null;
      state.aoePreview=[];
      renderAll();
    }

    function cpuTurn(){
      if(state.winner) return;
      if(gameMode!=='cpu') return;
      if(state.currentPlayer!==cpuPlayer) return;

      const me=state.currentPlayer;
      logMessage('é»’ï¼ˆCPUï¼‰ãŒæ€è€ƒä¸­â€¦');

      const myHand=state.hands[me];
      if(myHand.length>0 && !state.cardPlayedThisTurn && !isCardLocked(me)){
        let idx=myHand.findIndex(c=>c.type==='smite'||c.type==='plague'||c.type==='divine'||c.type==='chain');
        if(idx===-1) idx=0;
        playCardFor(me,idx);
        if(state.targeting) cpuResolveTargeting();
      }

      if(!isPlayerTimeStopped(me)) cpuMovePiece();
      else{
        logMessage('æ··ä¹±ã®åŠ¹æœã§CPUã¯é§’ã‚’å‹•ã‹ã›ãªã„ã€‚');
        endTurn();
      }
    }

    function cpuResolveTargeting(){
      const t=state.targeting;
      if(!t) return;

      const me=state.currentPlayer;
      const enemy=me==='white'?'black':'white';

      if(t.type==='smite'||t.type==='chain'){
        let targetCell=null, kingCell=null;
        for(let y=0;y<BOARD_SIZE;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            const p=state.board[y][x];
            if(!p||p.player!==enemy) continue;
            if(p.type===PieceType.KING){ kingCell={x,y}; break; }
            if(!targetCell) targetCell={x,y};
          }
          if(kingCell) break;
        }
        const choice=kingCell||targetCell;
        if(choice) handleTargetingClick(choice.x,choice.y,state.board[choice.y][choice.x]);
        else{ state.targeting=null; state.aoePreview=[]; renderAll(); }
        return;
      }

      if(t.type==='plague'){
        let bestCell=null, bestScore=-1;
        for(let cy=0;cy<BOARD_SIZE;cy++){
          for(let cx=0;cx<BOARD_SIZE;cx++){
            let score=0;
            for(let dy=-1;dy<=1;dy++){
              for(let dx=-1;dx<=1;dx++){
                const nx=cx+dx, ny=cy+dy;
                if(nx<0||nx>=BOARD_SIZE||ny<0||ny>=BOARD_SIZE) continue;
                if(state.board[ny][nx]) score++;
              }
            }
            if(score>bestScore){ bestScore=score; bestCell={x:cx,y:cy}; }
          }
        }
        handleTargetingClick(bestCell.x,bestCell.y,state.board[bestCell.y][bestCell.x]||null);
        return;
      }

      if(t.type==='divine'){
        let kingCell=null, enemyCell=null;
        for(let y=0;y<BOARD_SIZE;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            const p=state.board[y][x];
            if(!p||p.player!==enemy) continue;
            if(p.type===PieceType.KING){ kingCell={x,y}; break; }
            if(!enemyCell) enemyCell={x,y};
          }
          if(kingCell) break;
        }
        const choice=kingCell||enemyCell||{x:3,y:3};
        handleTargetingClick(choice.x,choice.y,state.board[choice.y][choice.x]||null);
        return;
      }

      if(t.type==='terrain'){
        let cell=null;
        for(let y=0;y<BOARD_SIZE && !cell;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            if(!state.board[y][x] && !state.terrainBlocks.some(b=>b.x===x&&b.y===y)){ cell={x,y}; break; }
          }
        }
        if(cell) handleTargetingClick(cell.x,cell.y,null);
        else{ state.targeting=null; state.aoePreview=[]; renderAll(); }
        return;
      }

      if(t.type==='escape'){
        let cell=null;
        for(let y=0;y<BOARD_SIZE && !cell;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            if(!state.board[y][x] && !isSquareBlockedForPlayer(x,y,state.currentPlayer)){ cell={x,y}; break; }
          }
        }
        if(cell) handleTargetingClick(cell.x,cell.y,null);
        else{ state.targeting=null; state.aoePreview=[]; renderAll(); }
        return;
      }

      if(t.type==='force'){
        const candidates=[];
        for(let y=0;y<BOARD_SIZE;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            const p=state.board[y][x];
            if(!p||p.player!==me) continue;
            if(p.type===PieceType.KING||p.type===PieceType.CASTLE) continue;
            candidates.push({x,y});
          }
        }
        if(candidates.length===0){ state.targeting=null; state.aoePreview=[]; renderAll(); return; }
        const from=candidates[Math.floor(Math.random()*candidates.length)];
        let dest=null;
        for(let y=0;y<BOARD_SIZE && !dest;y++){
          for(let x=0;x<BOARD_SIZE;x++){
            if(state.board[y][x]) continue;
            if(isSquareBlockedForPlayer(x,y,me)) continue;
            dest={x,y}; break;
          }
        }
        if(!dest){ state.targeting=null; state.aoePreview=[]; renderAll(); return; }
        const piece=state.board[from.y][from.x];
        state.board[from.y][from.x]=null;
        state.board[dest.y][dest.x]=piece;
        recordCellAction(from.x,from.y);
        recordCellAction(dest.x,dest.y);
        state.aoePreview=[{x:dest.x,y:dest.y}];
        logMessage(`é»’ã®${pieceName(piece)}ãŒã€Œãƒ•ã‚©ãƒ¼ã‚¹ã®å°ãã€ã§ (${dest.x},${dest.y}) ã«ç¬é–“ç§»å‹•ã—ãŸã€‚`);
        checkTrapAt(dest.x,dest.y,piece);
        state.targeting=null;
        renderAll();
        return;
      }

      state.targeting=null; state.aoePreview=[]; renderAll();
    }

    function cpuMovePiece(){
      const me=state.currentPlayer;
      const enemy=me==='white'?'black':'white';
      let bestMove=null;

      for(let y=0;y<BOARD_SIZE;y++){
        for(let x=0;x<BOARD_SIZE;x++){
          const p=state.board[y][x];
          if(!p||p.player!==me) continue;
          const moves=getValidMoves(x,y);
          for(const m of moves){
            const target=state.board[m.y][m.x];
            if(target && target.player===enemy){
              movePiece(x,y,m.x,m.y);
              return;
            }
            if(!bestMove) bestMove={fromX:x,fromY:y,toX:m.x,toY:m.y};
          }
        }
      }

      if(bestMove) movePiece(bestMove.fromX,bestMove.fromY,bestMove.toX,bestMove.toY);
      else{ logMessage('CPUã¯å‹•ã‘ã‚‹é§’ãŒãªã‹ã£ãŸâ€¦ã€‚'); endTurn(); }
    }

    function checkAnnihilationVictory(){
      if(state.winner) return;
      const whiteCount=countPieces('white');
      const blackCount=countPieces('black');

      if(whiteCount===0 && blackCount===0){
        logMessage('ä¸¡è»ã¨ã‚‚é§’ãŒå…¨æ»…ã—ãŸâ€¦ã€‚');
        endGame('draw');
      }else if(whiteCount===0){
        logMessage('ç™½ã®é§’ãŒå…¨æ»…ã—ãŸï¼');
        endGame('black');
      }else if(blackCount===0){
        logMessage('é»’ã®é§’ãŒå…¨æ»…ã—ãŸï¼');
        endGame('white');
      }
    }

    function checkHiyerDepletionVictory(){
      if(state.winner) return;
      const decksEmpty = state.decks.white.length===0 && state.decks.black.length===0;
      const handsEmpty = state.hands.white.length===0 && state.hands.black.length===0;
      if(!(decksEmpty && handsEmpty)) return;

      const whiteCount=countPieces('white');
      const blackCount=countPieces('black');
      const whiteKingAlive=!!findKing('white');
      const blackKingAlive=!!findKing('black');

      logMessage(`ãƒã‚¤ãƒ¤ãƒ¼ãŒå°½ããŸã€‚ç™½ã®é§’:${whiteCount}ï¼é»’ã®é§’:${blackCount}ï¼ç™½ã‚­ãƒ³ã‚°:${whiteKingAlive?'ç”Ÿå­˜':'ä¸åœ¨'}ï¼é»’ã‚­ãƒ³ã‚°:${blackKingAlive?'ç”Ÿå­˜':'ä¸åœ¨'}`);

      if(whiteKingAlive && !blackKingAlive) endGame('white');
      else if(!whiteKingAlive && blackKingAlive) endGame('black');
      else{
        if(whiteCount>blackCount) endGame('white');
        else if(blackCount>whiteCount) endGame('black');
        else endGame('draw');
      }
    }

    function checkTurnLimitVictory(){
      if(state.winner) return;
      if(state.turnCount<=MAX_TURNS) return;

      logMessage(`ã‚¿ãƒ¼ãƒ³åˆ¶é™ï¼ˆ${MAX_TURNS}ã‚¿ãƒ¼ãƒ³ï¼‰ã«åˆ°é”ã€‚é§’æ•°ãƒ»ã‚­ãƒ³ã‚°ç”Ÿå­˜ã§åˆ¤å®šã€‚`);

      const whiteCount=countPieces('white');
      const blackCount=countPieces('black');
      const whiteKingAlive=!!findKing('white');
      const blackKingAlive=!!findKing('black');

      if(whiteKingAlive && !blackKingAlive) endGame('white');
      else if(!whiteKingAlive && blackKingAlive) endGame('black');
      else{
        if(whiteCount>blackCount) endGame('white');
        else if(blackCount>whiteCount) endGame('black');
        else endGame('draw');
      }
    }

    function endGame(winner){
      if(state.winner) return;
      state.winner=winner;
      if(winner==='draw') logMessage('å¼•ãåˆ†ã‘ã€‚');
      else logMessage(`${winner==='white'?'ç™½':'é»’'}ã®å‹åˆ©ï¼`);
      playSfx('win');
      renderAll();
    }

    function pushReplayForCurrentTurn(){
      const player=state.currentPlayer;
      const label=player==='white'?'ç™½':'é»’';
      const start=state.turnStartLogIndex||0;
      const logs=state.log.slice(start);
      if(!logs.length && (!state.turnActionCells || !state.turnActionCells.length)){
        state.lastReplayText=`${label}ã®å‰ã‚¿ãƒ¼ãƒ³ï¼šç‰¹ã«è¡Œå‹•ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`;
      }else{
        const short=logs.slice(-5);
        state.lastReplayText=`${label}ã®å‰ã‚¿ãƒ¼ãƒ³ï¼š` + short.join(' / ');
      }
      state.lastTurnHighlight={ player, cells: state.turnActionCells ? state.turnActionCells.slice() : [] };
      state.turnActionCells=[];
      state.turnStartLogIndex=state.log.length;
    }

    function endTurn(){
      if(state.winner) return;

      const current=state.currentPlayer;
      const handHasCard=state.hands[current].length>0;

      if(!state.cardPlayedThisTurn && handHasCard && !isCardLocked(current)){
        logMessage('ã“ã®ã‚¿ãƒ¼ãƒ³ã¯ã¾ã ãƒã‚¤ãƒ¤ãƒ¼ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã„ã¾ã›ã‚“ã€‚');
        renderAll(); return;
      }

      pushReplayForCurrentTurn();

      state.targeting=null;
      state.aoePreview=[];

      if(state.activeEffect && state.activeEffect.type==='speed' && state.activeEffect.player===current){
        state.activeEffect=null;
      }

      if(state.timeStop[current] && state.timeStop[current].active){
        state.timeStop[current].active=false;
      }

      if(state.cardLock[current]) state.cardLock[current]=false;

      // âœ… ã‚¿ãƒ¼ãƒ³ãŒå¤‰ã‚ã‚‹ã®ã§ã€Œã“ã®ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã€ãƒªã‚»ãƒƒãƒˆ
      state.usedCardThisTurn=null;

      state.currentPlayer = current==='white' ? 'black' : 'white';
      state.selectedCell=null;
      state.validMoves=[];
      state.turnCount += 1;
      state.cardPlayedThisTurn=false;

      const gb=state.guardBarrier[state.currentPlayer];
      if(gb && gb.active && gb.hitsLeft>0){
        gb.active=false;
        logMessage(`${state.currentPlayer==='white'?'ç™½':'é»’'}å´ã®å®ˆè­·çµç•Œã®åŠ¹æœãŒæ¶ˆãˆãŸã€‚`);
      }

      healAdjacentByMonk(state.currentPlayer);
      drawCard(state.currentPlayer);

      const turnLabel = (gameMode==='cpu')
        ? (state.currentPlayer==='white' ? 'ç™½ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰' : 'é»’ï¼ˆCPUï¼‰')
        : (state.currentPlayer==='white' ? 'ç™½ï¼ˆP1ï¼‰' : 'é»’ï¼ˆP2ï¼‰');

      logMessage(`${turnLabel}ã®ã‚¿ãƒ¼ãƒ³ã€‚`);
      state.turnStartLogIndex = state.log.length;

      renderAll();
      if(!state.winner){
        checkHiyerDepletionVictory();
        checkTurnLimitVictory();
      }

      if(!state.winner && gameMode==='cpu' && state.currentPlayer===cpuPlayer){
        setTimeout(cpuTurn,400);
      }
    }

    function logMessage(msg){
      const time=new Date().toLocaleTimeString();
      state.log.push(`[${time}] ${msg}`);
      if(state.log.length>200){
        state.log.shift();
        if(typeof state.turnStartLogIndex==='number' && state.turnStartLogIndex>0){
          state.turnStartLogIndex=Math.max(0,state.turnStartLogIndex-1);
        }
      }
    }

    document.getElementById('modeCpuBtn').addEventListener('click',()=>initGame('cpu'));
    document.getElementById('modePvpBtn').addEventListener('click',()=>initGame('pvp'));
    document.getElementById('bgmBtn').addEventListener('click',toggleBgm);
    document.getElementById('endTurnBtn').addEventListener('click',()=>endTurn());

    initGame('cpu');
  </script>
</body>
</html>
